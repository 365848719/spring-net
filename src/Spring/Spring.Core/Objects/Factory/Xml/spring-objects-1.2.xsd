<?xml version="1.0" encoding="UTF-8" ?>
<xsd:schema xmlns="http://www.springframework.net"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:vs="http://schemas.microsoft.com/Visual-Studio-Intellisense"
            targetNamespace="http://www.springframework.net"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            vs:friendlyname="Spring.NET Configuration"
            vs:ishtmlschema="false"
            vs:iscasesensitive="true"
            vs:requireattributequotes="true"
            vs:defaultnamespacequalifier=""
            vs:defaultnsprefix="">

  <xsd:annotation>
    <xsd:documentation>
      <![CDATA[
	Spring XML Objects Schema, version 1.2
	Authors: Rob Harrop, Juergen Hoeller, Mark Fisher, Griffin Caprio (.NET)

	This defines a simple and consistent way of creating a namespace
	of objects, managed by a Spring IObjectFactory, read by
	XmlObjectDefinitionReader (with DefaultObjectDefinitionDocumentReader).

	This document type is used by most Spring functionality, including
	web application contexts, which are based on object factories.

	Each "object" element in this document defines a object.
	Typically the object class is specified, along with object properties
	and/or constructor arguments.

	An object instance can be a "singleton" (shared instance) or a "prototype"
	(independent instance). Further scopes can be provided by extended
	object factories, for example in a web environment.

	References among objects are supported, that is, setting an object property
	or a constructor argument to refer to another object in the same factory
	(or an ancestor factory).

	As alternative to object references, "inner object definitions" can be used.
	Singleton flags of such inner object definitions are effectively ignored:
	inner objects are typically anonymous prototypes.

  There is also support for lists, sets, name-value collections, dictionaries 
  and expressions as object property types or constructor argument types.
		]]>
    </xsd:documentation>
  </xsd:annotation>

  <!-- base types -->
  <xsd:complexType name="identifiedType" abstract="true">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	The unique identifier for an object. The scope of the identifier
	is the enclosing object factory.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="id" type="xsd:ID">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The unique identifier for an object.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- Top-level <objects> tag -->
  <xsd:element name="objects">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	The top level (typically root) element. Allows the definition
	of default values for all nested object definitions.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="description" minOccurs="0"/>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
          <xsd:element ref="import"/>
          <xsd:element ref="alias"/>
          <xsd:element ref="object"/>
          <xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:choice>
      </xsd:sequence>
      <xsd:attribute name="default-lazy-init" default="false" type="xsd:boolean">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	The default 'lazy-init' value; see the documentation for the
	'lazy-init' attribute of the '<object>/' element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="default-autowire" default="no">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	The default 'autowire' value; see the documentation for the
	'autowire' attribute of the '<object>/' element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleType>
          <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="no"/>
            <xsd:enumeration value="byName"/>
            <xsd:enumeration value="byType"/>
            <xsd:enumeration value="constructor"/>
            <xsd:enumeration value="autodetect"/>
          </xsd:restriction>
        </xsd:simpleType>
      </xsd:attribute>
      <xsd:attribute name="default-dependency-check" default="none">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	The default 'dependency-check' value; see the documentation for the
	'dependency-check' attribute of the '<object>/' element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleType>
          <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="none"/>
            <xsd:enumeration value="simple"/>
            <xsd:enumeration value="objects"/>
            <xsd:enumeration value="all"/>
          </xsd:restriction>
        </xsd:simpleType>
      </xsd:attribute>
      <xsd:anyAttribute namespace="##other" processContents="lax"/>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="description">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Contains informative text describing the purpose of the enclosing element.
	Used primarily for user documentation of XML object definition documents.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType mixed="true">
      <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="import">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Specifies an XML object definition resource to import.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:attribute name="resource" type="xsd:string" use="required">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The relative resource location of the XML (object definition) file to import,
	for example "myImport.xml" or "includes/myImport.xml" or "../myImport.xml".
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="alias">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Defines an alias for an object (which can reside in a different definition
	resource).
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:attribute name="name" type="xsd:string" use="required">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the object to define an alias for.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="alias" type="xsd:string" use="required">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The alias name to define for the object.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>

  <xsd:group name="objectElements">
    <xsd:sequence>
      <xsd:element ref="description" minOccurs="0"/>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element ref="constructor-arg"/>
        <xsd:element ref="property"/>
        <xsd:element ref="lookup-method"/>
        <xsd:element ref="replaced-method"/>
        <xsd:element ref="listener"/>
        <xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:group>

  <xsd:attributeGroup name="objectAttributes">
    <xsd:attribute name="name" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Can be used to create one or more aliases illegal in an (XML) id.
	Multiple aliases can be separated by any number of spaces, commas,
	or semi-colons (or indeed any mixture of the three).
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="type" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The fully or partially qualified name of the object's class, except 
	if it serves only as a parent definition for child object definitions.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="parent" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The name of the parent object definition.

	Will use the object class of the parent if none is specified, but can
	also override it. In the latter case, the child object class must be
	compatible with the parent, i.e. accept the parent's property values
	and constructor argument values, if any.

	A child object definition will inherit constructor argument values,
	property values and method overrides from the parent, with the option
	to add new values. If init method, destroy method, factory object and/or
	factory method are specified, they will override the corresponding
	parent settings.

	The remaining settings will always be taken from the child definition:
	depends on, autowire mode, dependency check, scope, lazy init.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="scope" use="optional" default="application">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
  Optional attribute controlling the scope of singleton instances. It is
  only applicable to ASP.NET web applications and it has no effect on prototype
  objects. Applications other than ASP.NET web applications simply ignore this attribute.
				]]>
        </xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="application">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
  Default object scope. Objects defined with application scope will behave like
  traditional singleton objects. Same instance will be returned from every call
  to IApplicationContext.GetObject()
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="session">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
  Objects with this scope will be stored within user's HTTP session. Session scope
  is typically used for objects such as shopping cart, user profile, etc.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="request">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
  Object with this scope will be initialized for each HTTP request, but unlike with prototype
  objects, same instance will be returned from all calls to IApplicationContext.GetObject()
  within the same HTTP request. For example, if one ASP page forwards request to another using
  Server.Transfer method, they can easily share the state by configuring dependency to the same
  request-scoped object.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="abstract" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Is this object "abstract", that is, not meant to be instantiated itself
	but rather just serving as parent for concrete child object definitions?
	The default is "false". Specify "true" to tell the object factory to not
	try to instantiate that particular object in any case.

	Note: This attribute will not be inherited by child object definitions.
	Hence, it needs to be specified per abstract object definition.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="lazy-init" default="default" type="defaultable-boolean">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Indicates whether or not this object is to be lazily initialized.
	If false, it will be instantiated on startup by object factories
	that perform eager initialization of singletons. The default is
	"false".

	Note: This attribute will not be inherited by child object definitions.
	Hence, it needs to be specified per concrete object definition.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="autowire" default="default">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Controls whether object properties are "autowired".
	This is an automagical process in which object references don't need
	to be coded explicitly in the XML object definition file, but rather the
	Spring container works out dependencies.

	There are 5 modes:

	1. "no"
	The traditional Spring default. No automagical wiring. Object references
	must be defined in the XML file via the <ref/> element (or "ref"
	attribute). We recommend this in most cases as it makes documentation
	more explicit.

	2. "byName"
	Autowiring by property name. If an object of class Cat exposes a dog
	property, Spring will try to set this to the value of the object "dog"
	in the current container. If there is no matching object by name, nothing
	special happens; use dependency-check="objects" to raise an error in
	that case.

	3. "byType"
	Autowiring if there is exactly one object of the property type in the
	container. If there is more than one, a fatal error is raised, and
	you cannot use byType autowiring for that object. If there is none,
	nothing special happens; use dependency-check="objects" to raise an
	error in that case.

	4. "constructor"
	Analogous to "byType" for constructor arguments. If there is not exactly
	one object of the constructor argument type in the object factory, a fatal
	error is raised.

	5. "autodetect"
	Chooses "constructor" or "byType" through introspection of the object
	class. If a default constructor is found, "byType" gets applied.

	Note that explicit dependencies, i.e. "property" and "constructor-arg"
	elements, always override autowiring. Autowire behavior can be combined
	with dependency checking, which will be performed after all autowiring
	has been completed.

	Note: This attribute will not be inherited by child object definitions.
	Hence, it needs to be specified per concrete object definition.
				]]>
        </xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="default">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	Controls whether object properties are "autowired".
	This is an automagical process in which object references don't need
	to be coded explicitly in the XML object definition file, but rather the
	Spring container works out dependencies.

	Note that explicit dependencies, i.e. "property" and "constructor-arg"
	elements, always override autowiring. Autowire behavior can be combined
	with dependency checking, which will be performed after all autowiring
	has been completed.

	Note: This attribute will not be inherited by child object definitions.
	Hence, it needs to be specified per concrete object definition.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="no">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The traditional Spring default. No automagical wiring. Object references
	must be defined in the XML file via the <ref/> element (or "ref"
	attribute). We recommend this in most cases as it makes documentation
	more explicit.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="byName">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	Autowiring by property name. If an object of class Cat exposes a dog
	property, Spring will try to set this to the value of the object "dog"
	in the current container. If there is no matching object by name, nothing
	special happens; use dependency-check="objects" to raise an error in
	that case.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="byType">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	Autowiring if there is exactly one object of the property type in the
	container. If there is more than one, a fatal error is raised, and
	you cannot use byType autowiring for that object. If there is none,
	nothing special happens; use dependency-check="objects" to raise an
	error in that case.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="constructor">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	Analogous to "byType" for constructor arguments. If there is not exactly
	one object of the constructor argument type in the object factory, a fatal
	error is raised.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="autodetect">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	Chooses "constructor" or "byType" through introspection of the object
	class. If a default constructor is found, "byType" gets applied.
				]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="dependency-check" default="default">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Controls whether or not to check whether all of this
	object's dependencies, expressed in its properties, are satisfied.
	The default is to perform no dependency checking.

	"simple" type dependency checking includes primitives and String;
	"objects" includes collaborators (other objects in the factory);
	"all" includes both types of dependency checking.

	Note: This attribute will not be inherited by child object definitions.
	Hence, it needs to be specified per concrete object definition.
				]]>
        </xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="default"/>
          <xsd:enumeration value="none"/>
          <xsd:enumeration value="simple"/>
          <xsd:enumeration value="objects"/>
          <xsd:enumeration value="all"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="depends-on" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The names of the objects that this object depends on being initialized.
	The object factory will guarantee that these objects get initialized
	before this object.

	Note that dependencies are normally expressed through object properties
	or constructor arguments. This property should just be necessary for
	other kinds of dependencies like statics (*ugh*) or database preparation
	on startup.

	Note: This attribute will not be inherited by child object definitions.
	Hence, it needs to be specified per concrete object definition.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="init-method" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The name of the custom initialization method to invoke after setting
	object properties. The method must have no arguments, but may throw any
	exception.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="destroy-method" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The name of the custom destroy method to invoke on object factory
	shutdown. The method must have no arguments, but may throw any
	exception.

	Note: Only invoked on objects whose lifecycle is under the full
	control of the factory - which is always the case for singletons,
	but not guaranteed for any other scope.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="factory-method" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The name of a factory method to use to create this object. Use
	constructor-arg elements to specify arguments to the factory method,
	if it takes arguments. Autowiring does not apply to factory methods.

	If the "type" attribute is present, the factory method will be a static
	method on the class specified by the "type" attribute on this object
	definition. Often this will be the same class as that of the constructed
	object - for example, when the factory method is used as an alternative
	to a constructor. However, it may be on a different class. In that case,
	the created object will *not* be of the class specified in the "type"
	attribute. This is analogous to IFactoryObject behavior.

	If the "factory-object" attribute is present, the "type" attribute is not
	used, and the factory method will be an instance method on the object
	returned from a GetObject call with the specified object name. The factory
	object may be defined as a singleton or a prototype.

	The factory method can have any number of arguments. Autowiring is not
	supported. Use indexed constructor-arg elements in conjunction with the
	factory-method attribute.

	Setter Injection can be used in conjunction with a factory method.
	Method Injection cannot, as the factory method returns an instance,
	which will be used when the container creates the object.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="factory-object" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Alternative to type attribute for factory-method usage.
	If this is specified, no type attribute should be used.
	This must be set to the name of an object in the current or
	ancestor factories that contains the relevant factory method.
	This allows the factory itself to be configured using Dependency
	Injection, and an instance (rather than static) method to be used.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:anyAttribute namespace="##other" processContents="lax"/>
  </xsd:attributeGroup>

  <xsd:element name="object">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Defines a single (usually named) object.

	An object definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same object is explicitly supported.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:extension base="identifiedType">
          <xsd:group ref="objectElements"/>
          <xsd:attributeGroup ref="objectAttributes"/>
        </xsd:extension>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="constructor-arg">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Object definitions can specify zero or more constructor arguments.
	This is an alternative to "autowire constructor".
	Arguments correspond to either a specific index of the constructor
	argument list or are supposed to be matched generically by type.

	constructor-arg elements are also used in conjunction with the
	factory-method element to construct objects using static or instance
	factory methods.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="description" minOccurs="0"/>
        <xsd:choice minOccurs="0" maxOccurs="1">
          <xsd:element ref="object"/>
          <xsd:element ref="ref"/>
          <xsd:element ref="idref"/>
          <xsd:element ref="value"/>
          <xsd:element ref="expression"/>
          <xsd:element ref="null"/>
          <xsd:element ref="list"/>
          <xsd:element ref="set"/>
          <xsd:element ref="dictionary"/>
          <xsd:element ref="name-values"/>
          <xsd:any namespace="##other" processContents="strict"/>
        </xsd:choice>
      </xsd:sequence>
      <xsd:attribute name="index" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
  The constructor-arg tag can have an optional index attribute,
  to specify the exact index in the constructor argument list.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="name" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
  The constructor-arg tag can have an optional named parameter attribute, 
  to specify a named parameter in the constructor argument list.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="type" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
  The constructor-arg tag can have an optional type attribute,
  to specify the exact type of the constructor argument. Only needed
  to avoid ambiguities, e.g. in case of 2 single argument constructors
  that can both be converted from a String.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ref" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	A short-cut alternative to a nested "<ref object='...'/>" element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="value" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	A short-cut alternative to a nested "<value>...<value/>" element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="expression" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	A short-cut alternative to a nested "<expression value='...'/>" element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="property" type="propertyType">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
  Object definitions can have zero or more properties.
  Property elements correspond to object properties exposed by the object classes.
  Spring supports primitives, expressions, references to otherobjects in the same 
  or related factories, lists, sets, name-value collections and dictionaries.
			]]>
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:complexType name="propertyType">
    <xsd:sequence>
      <xsd:element ref="description" minOccurs="0"/>
      <xsd:choice minOccurs="0" maxOccurs="1">
        <xsd:element ref="object"/>
        <xsd:element ref="ref"/>
        <xsd:element ref="idref"/>
        <xsd:element ref="value"/>
        <xsd:element ref="expression"/>
        <xsd:element ref="null"/>
        <xsd:element ref="list"/>
        <xsd:element ref="set"/>
        <xsd:element ref="dictionary"/>
        <xsd:element ref="name-values"/>
        <xsd:any namespace="##other" processContents="strict"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	The name of the property, following object naming conventions.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="ref" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a nested "<ref object='...'/>" element.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="value" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a nested "<value>...</value>" element.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="expression" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a nested "<expression value='...'/>" element.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <xsd:element name="lookup-method">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	A lookup method causes the IoC container to override the given method
	and return the object with the name given in the object attribute. This is
	a form of Method Injection. It is particularly useful as an alternative
	to implementing the IObjectFactoryAware interface, in order to be able to
	make GetObject() calls for non-singleton instances at runtime. In this
	case, Method Injection is a less invasive alternative.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:attribute name="name" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the lookup method. This method must take no arguments.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="object" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the object in the current or ancestor factories that
	the lookup method should resolve to. Often this object will be a
	prototype, in which case the lookup method will return a distinct
	instance on every invocation. This is useful for single-threaded objects.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="replaced-method">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Similar to the lookup method mechanism, the replaced-method element
	is used to control IoC container method overriding: Method Injection.
	This mechanism allows the overriding of a method with arbitrary code.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
          <xsd:element ref="arg-type"/>
        </xsd:choice>
      </xsd:sequence>
      <xsd:attribute name="name" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	The name of the method whose implementation must be replaced by the
	IoC container. If this method is not overloaded, there is no need
	to use arg-type subelements. If this method is overloaded, arg-type
	subelements must be used for all override definitions for the method.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="replacer" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	Object name of an implementation of the IMethodReplacer interface in the
	current or ancestor factories. This may be a singleton or prototype
	object. If it is a prototype, a new instance will be used for each
	method replacement. Singleton usage is the norm.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="arg-type">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Identifies an argument for a replaced method in the event of
	method overloading.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType mixed="true">
      <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
      <xsd:attribute name="match" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	Specification of the type of an overloaded method argument as a String.
	For convenience, this may be a substring of the FQN. 
   E.g. all the following would match "System.String":
	- System.String
	- String
	- Str

	As the number of arguments will be checked also, this convenience
	can often be used to save typing.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="listener">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
  Object definitions can have zero or more subscriptions.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:choice minOccurs="0" maxOccurs="unbounded">
          <xsd:element name="ref">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	Defines a reference to another object in this factory or to a type.
			]]>
              </xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
              <xsd:complexContent>
                <xsd:restriction base="xsd:anyType">
                  <xsd:attribute name="object" type="xsd:string">
                    <xsd:annotation>
                      <xsd:documentation>
                        <![CDATA[
	The name of the referenced object.
							]]>
                      </xsd:documentation>
                    </xsd:annotation>
                  </xsd:attribute>
                  <xsd:attribute name="local" type="xsd:IDREF">
                    <xsd:annotation>
                      <xsd:documentation>
                        <![CDATA[
	The name of the referenced object. The value must be an object ID and thus can 
	be checked by the XML parser. This is therefore the preferred technique 
	for referencing objects within the same object factory XML file.
							]]>
                      </xsd:documentation>
                    </xsd:annotation>
                  </xsd:attribute>
                  <xsd:attribute name="type" type="xsd:string">
                    <xsd:annotation>
                      <xsd:documentation>
                        <![CDATA[
	The type of the object.
						]]>
                      </xsd:documentation>
                    </xsd:annotation>
                  </xsd:attribute>
                </xsd:restriction>
              </xsd:complexContent>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:sequence>
      <xsd:attribute name="event" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
  The event(s) the object is interested in.
			]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="method" type="xsd:string" use="required">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
  The name or name pattern of the method that will handle the event(s).
			]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="ref">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Defines a reference to another object in this factory or an external
	factory (parent or included factory).
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:attribute name="object" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the referenced object.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="local" type="xsd:IDREF">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the referenced object. The value must be an object ID and thus can 
	be checked by the XML parser. This is therefore the preferred technique 
	for referencing objects within the same object factory XML file.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="parent" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the referenced object *in a parent factory*.
						]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="idref">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	The id of another object in this factory or an external factory
	(parent or included factory).
	While a regular 'value' element could instead be used for the
	same effect, using idref in this case allows validation of local
	object ids by the XML parser, and name completion by supporting tools.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:attribute name="object" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the referenced object.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="local" type="xsd:IDREF">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the referenced object. The value must be an object ID and thus can 
	be checked by the XML parser. This is therefore the preferred technique 
	for referencing objects within the same object factory XML file.
							]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="parent" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	The name of the referenced object *in a parent factory*.
						]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="expression">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
  TODO (Contains a string representation of an expression.)
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:choice minOccurs="0" maxOccurs="2">
          <xsd:element ref="property"/>
        </xsd:choice>
      </xsd:sequence>
      <xsd:attribute name="value" type="xsd:string" use="required">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
  TODO
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="value">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the required
	type using the TypeConverter machinery. This makes it possible 
	for application developers to write custom TypeConverter
	implementations that can convert strings to arbitrary target objects.

	Note that this is recommended for simple objects only. Configure
	more complex objects by populating object properties with
	references to other objects.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType mixed="true">
      <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
      <xsd:attribute name="type" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	The exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
					]]>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="null">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	Denotes a C# null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special TypeConverter does so.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType mixed="true">
      <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    </xsd:complexType>
  </xsd:element>


  <!-- Collection Elements -->

  <xsd:group name="collectionElements">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element ref="object"/>
        <xsd:element ref="ref"/>
        <xsd:element ref="idref"/>
        <xsd:element ref="value"/>
        <xsd:element ref="expression"/>
        <xsd:element ref="null"/>
        <xsd:element ref="list"/>
        <xsd:element ref="set"/>
        <xsd:element ref="dictionary"/>
        <xsd:element ref="name-values"/>
        <xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:group>

  <xsd:element name="list" type="listOrSetType">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
  A list can contain multiple inner object, ref, collection, or value
  elements. TODO (generics). A list can also map to an array type. 
  The necessary conversion is automatically performed by the IObjectFactory.
			]]>
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="set" type="listOrSetType">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
  A set can contain multiple inner object, ref, collection, or value
  elements. TODO (generics).
			]]>
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="name-values" type="nameValuesType">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
  Name-values elements differ from dictionary elements in that values must be strings. 
  Dictionaries may be empty.
			]]>
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="dictionary" type="dictionaryType">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	A mapping from a key to an object. Dictionaries may be empty.
			]]>
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="entry" type="entryType">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	A dictionary entry can be an inner object, ref, value, expression or collection.
	The key of the entry is given by the "key" attribute or child element.
			]]>
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="key">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[
	A key element can contain an inner object, ref, value, expression or collection.
			]]>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:group ref="collectionElements"/>
    </xsd:complexType>
  </xsd:element>


  <!-- Collection Types -->

  <!-- 'dictionary' element type -->
  <xsd:complexType name="dictionaryType">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element ref="entry"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="key-type" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	TODO (default type for .NET 1.x; generics for .NET 2.0)
						]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="value-type" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	TODO (generics for .NET 2.0)
						]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- 'entry' element type -->
  <xsd:complexType name="entryType">
    <xsd:sequence>
      <xsd:element ref="key" minOccurs="0"/>
      <xsd:group ref="collectionElements"/>
    </xsd:sequence>
    <xsd:attribute name="key" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	Each dictionary element must specify its key as attribute or as child element.
	A key attribute is always a String value.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="key-ref" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a "key" element with a nested "<ref object='...'/>".
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="value" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a nested "<value>...</value>" element.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="value-ref" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a nested "<ref object='...'/>" element.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="expression" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	A short-cut alternative to a nested "<expression value='...'/>" element.
				]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- 'list' and 'set' collection type -->
  <xsd:complexType name="listOrSetType">
    <xsd:sequence>
      <xsd:group ref="collectionElements"/>
    </xsd:sequence>
    <xsd:attribute name="element-type" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>
          <![CDATA[
	TODO (default type for .NET 1.x; generics for .NET 2.0)
						]]>
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- 'name-values' collection type -->
  <xsd:complexType name="nameValuesType">
    <xsd:sequence>
      <xsd:element name="add" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            <![CDATA[
	TODO
						]]>
          </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType mixed="true">
          <xsd:attribute name="key" type="xsd:string" use="required">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	TODO
						]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="value" type="xsd:string" use="required">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	TODO
						]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="delimiters" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>
                <![CDATA[
	TODO
						]]>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:attribute>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>


  <!-- Simple internal types -->

  <xsd:simpleType name="defaultable-boolean">
    <xsd:restriction base="xsd:NMTOKEN">
      <xsd:enumeration value="default"/>
      <xsd:enumeration value="true"/>
      <xsd:enumeration value="false"/>
    </xsd:restriction>
  </xsd:simpleType>

</xsd:schema>
